@page "/"
@using Tauron.Application.ServiceManager.AppCore.ClusterTracking
@using DynamicData
@using System.Reactive.Linq

@inherits DisposingComponent

@inject IClusterNodeManager _nodeManager;

<Title Value="Knoten" />

<MudText Typo="Typo.h4" Class="m-1">Aktuelle Knoten:</MudText>

<MudList>
    @foreach (var info in _nodeInfos)
    {
        <MudListItem>
            <ClusterNodeInfoView @key=info.Key NodeInfo="@info.Value"/>
        </MudListItem>
    }
</MudList>

@code
{
    private readonly Dictionary<string, ClusterNodeInfo> _nodeInfos = new();

    protected override async Task OnInitializedAsync()
    {
        var set = await _nodeManager.GetMemberChangeSet(new GetAllMemberChangeset());
        set.Observable
           .Synchronize(_nodeInfos)
           .ForEachChange(c =>
                          {
                              string url = c.Current.Member.Address.ToString();
                              ClusterNodeInfo targetInfo;

                              switch (c)
                              {
                                  case {Reason: ChangeReason.Add}:
                                      targetInfo = new ClusterNodeInfo(c.Current.Member.Address.ToString(), c.Current);
                                      _nodeInfos[url] = targetInfo;
                                      InvokeAsync(StateHasChanged);
                                      return;
                                  case {Reason: ChangeReason.Remove}:
                                      if (_nodeInfos.Remove(url))
                                          InvokeAsync(StateHasChanged);
                                      return;
                                  default:
                                      if (_nodeInfos.TryGetValue(url, out targetInfo!))
                                          break;
                                      return;
                              }

                              targetInfo.Update(c.Current);
                          })
           .Subscribe()
           .DisposeWith(this);

    }
}

