@using Tauron.Application
@implements IDisposable

@inject IEventAggregator _aggregator;

<MudContainer MaxWidth="MaxWidth.Large">
    @if (Context == null)
    {
        <MudText>Kein Kontext Vervügbar</MudText>
    }
    else
    {
        <MudCard>
            <MudCardHeader>
                <CardHeaderContent>
                    @if (Context.CurrentPage != null)
                    {
                        <MudText>@Context.CurrentPage.Title</MudText>
                    }
                    else
                    {
                        <MudText>Bitte warten</MudText>
                    }
                </CardHeaderContent>
                <CardHeaderActions>
                    <MudIconButton Icon="@Icons.Filled.Cancel" OnClick="CancelCallback)"/>
                </CardHeaderActions>
            </MudCardHeader>
            <MudCardContent>
                <CascadingValue Value="Context.CurrentPage">
                    <CascadingValue Value="Context">
                        @RenderPage((_currentPage.Page, NextCallback, this));
                    </CascadingValue>
                </CascadingValue>
            </MudCardContent>
            @if (Context.CurrentPage?.ShowControls == true)
            {
                <MudCardActions>
                    <MudButton OnClick="BackCallback" Disabled="CanBack()">Zurück</MudButton>
                    @foreach(var (label, handler) in Context.CurrentPage.CustomActions)
                    {
                        <MudButton OnClick="handler" Disabled="_loading">@label</MudButton>
                    }
                    <MudButton OnClick="NextCallback" Disabled="CanNext()">Weiter</MudButton>
                </MudCardActions>
            }
        </MudCard>
    }
</MudContainer>

@code {

    private static readonly RenderFragment<(Type? Type, Func<Task> Next, object Reciever)> RenderPage =
        dat => b =>
               {
                   var (comp, callback, reciever) = dat;
                   if (comp == null)
                       return;

                   b.OpenComponent(0, comp);
                   b.AddAttribute(1, "OnNext", EventCallback.Factory.Create(reciever, callback));
                   b.CloseComponent();
               };

    [Parameter]
    public WizardContextBase? Context { get; set; }
    
    [Parameter]
    public EventCallback OnCancel { get; set; }

    private (Type? Page, CancellationTokenSource? Source) _currentPage;

    private bool _loading = true;
    
    private readonly CancellationTokenSource _mainSource = new();

    public void Dispose()
    {
        _mainSource.Cancel();
        _mainSource.Dispose();
    }

    protected override Task OnInitializedAsync() => NextCallback();

    private async Task BackCallback()
    {
        if(Context == null) return;
        
        _currentPage.Source?.Dispose();
        var newSource = CancellationTokenSource.CreateLinkedTokenSource(_mainSource.Token);

        try
        {
            _currentPage = (await Context.Back(newSource.Token), newSource);
        }
        catch
        {
            newSource.Dispose();
            throw;
        }
    }

    private async Task NextCallback()
    {
        if(Context == null) return;

        _loading = true;
        StateHasChanged();

        await (Context.CurrentPage?.BeforeNext(Context) ?? Task.CompletedTask);

        var err = Context.CurrentPage == null ? null : await Context.CurrentPage.VerifyNext(Context, _mainSource.Token);
        if (!string.IsNullOrWhiteSpace(err))
        {
            _aggregator.PublishWarnig($"Fehler: {err}");
            return;
        }
        
        _currentPage.Source?.Dispose();
        var newSource = CancellationTokenSource.CreateLinkedTokenSource(_mainSource.Token);

        try
        {
            _currentPage = (await Context.Next(newSource.Token), newSource);
        }
        catch
        {
            newSource.Dispose();
            throw;
        }

        _loading = false;
        StateHasChanged();
    }

    private Task CancelCallback()
    {
        _mainSource.Cancel();
        return OnCancel.InvokeAsync();
    }

    private bool CanBack()
        => _loading || Context?.CanNext() == true;

    private bool CanNext()
        => _loading || Context?.CanNext() == true;

}