@using System.Reactive.Disposables
@inherits NonAutoRenderingComponent

@inject IJobDatabaseService _jobDatabase
@inject IEventAggregator _aggregator

<div class="d-flex my-n3">
    <MudIconButton Icon="@Icons.Outlined.ArrowUpward" Disabled="CanNotGoUp" OnClick="GoUp"/>
    <MudIconButton Icon="@Icons.Outlined.ArrowDownward" Disabled="CanNotGoDown" OnClick="GoDown"/>
    <MudButton StartIcon="@Icons.Outlined.AddTask" Disabled="CanNotPriority" OnClick="Priorize">Priorisieren</MudButton>
</div>

@code {

    [Parameter]
    public JobsViewModel? Model { get; set; }

    [Parameter]
    public ImmutableList<JobSortOrderPair> ActivePairs { get; set; } = ImmutableList<JobSortOrderPair>.Empty;

    private IDisposable _currentSubsrciption = Disposable.Empty;
    private JobSortOrderPair? _info;
    private bool _canGoUp;
    private bool _canGoDown;
    private bool _canPriority;

    private bool CanNotGoUp => _processing || !_canGoUp;
    private bool CanNotGoDown => _processing || !_canGoDown;
    private bool CanNotPriority => _processing || !_canPriority;

    private bool _processing;

    protected override void OnParametersSet()
    {
        RemoveResource(_currentSubsrciption);

        _currentSubsrciption = 
            Model?.CurrentInfo
            .Subscribe(NewJobIncomming)
            .DisposeWith(this) ?? Disposable.Empty;

        base.OnParametersSet();
    }

    private async Task GoUp()
    {
        if(_info == null) return;
        var index = ActivePairs.IndexOf(_info) - 1;
        if(index == -1) return;

        await RenderingManager.PerformTask(
            () => _processing = true,
            () => _processing = false,
            () => _aggregator.IsSuccess(() => TimeoutToken.WithDefault(
                token => _jobDatabase.ChangeOrder(new SetSortOrder(_info.Info.Project, new SortOrder(ActivePairs[index].Order.Value + 100)), token))));
    }

    private async Task GoDown()
    {
        if (_info == null) return;

        var index = ActivePairs.IndexOf(_info) + 1;
        if (index == ActivePairs.Count) return;

        await RenderingManager.PerformTask(
            () => _processing = true,
            () => _processing = false,
            () => _aggregator.IsSuccess(() => TimeoutToken.WithDefault(
                token => _jobDatabase.ChangeOrder(new SetSortOrder(_info.Info.Project, new SortOrder(ActivePairs[index].Order.Value - 100)), token))));
    }

    private async Task Priorize()
    {
        if(_info == null || _info.Order.Value < 0) return;

        await RenderingManager.PerformTask(
            () => _processing = true,
            () => _processing = false,
            () => _aggregator.IsSuccess(() => TimeoutToken.WithDefault(
                token => _jobDatabase.ChangeOrder(new SetSortOrder(_info.Info.Project, new SortOrder(_info.Order.Value * -1)), token))));
    }

    private void NewJobIncomming(JobSortOrderPair? info)
    {
        Console.WriteLine($"New Job for Priority Control: {info}");

        void Invalid()
        {
            Console.WriteLine("Job Priority Control: AllInvalid");

            _canPriority = false;
            _canGoUp = false;
            _canGoDown = false;
        }

        _info = info;

        if (info != null && ActivePairs.Count != 0)
        {
            _canPriority = info.Order.Value > 0;
            
            if (!ActivePairs.Contains(info))
                Invalid();
            else
            {
                _canGoUp = ActivePairs[0] != info;
                _canGoDown = ActivePairs.Last() != info;
            }
            
        }
        else
            Invalid();

        RenderingManager.StateHasChanged();
    }
}
